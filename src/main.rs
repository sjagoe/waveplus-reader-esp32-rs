use anyhow::{bail, Result};
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    hal::{prelude::Peripherals, sys::esp_restart},
    nvs::EspDefaultNvsPartition,
    wifi::{EspWifi, WifiEvent},
};

mod ble;
mod http;
mod measurement;
mod rgbled;
mod wifi;
mod wifi_fix;

use ble::read_waveplus;
use http::send_measurement;
use rgbled::{RGB8, WS2812RMT};
use wifi::connect_wifi;

/// This configuration is picked up at compile time by `build.rs` from the
/// file `cfg.toml`.
#[toml_cfg::toml_config]
pub struct Config {
    #[default("Wokwi-GUEST")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
    #[default("")]
    waveplus_serial: &'static str,
    #[default(30)]
    read_interval: u16,
    #[default("")]
    server: &'static str,
}

fn main() -> Result<()> {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sysloop = EspSystemEventLoop::take()?;
    let nvs_default_partition = EspDefaultNvsPartition::take()?;

    log::info!("Hello, world!");

    // Start the LED off yellow
    let mut led = WS2812RMT::new(peripherals.pins.gpio8, peripherals.rmt.channel0)?;
    led.set_pixel(RGB8::new(50, 50, 0))?;

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    if app_config.wifi_ssid.is_empty() {
        bail!("Missing WiFi name")
    }
    let serial: u32 = app_config.waveplus_serial.parse()?;

    log::info!("SSID: {:?}", app_config.wifi_ssid);

    let mut esp_wifi = EspWifi::new(
        peripherals.modem,
        sysloop.clone(),
        Some(nvs_default_partition),
    )?;
    let _wifi_event_sub = sysloop.subscribe::<WifiEvent, _>(move |event| {
        log::warn!("Received wifi event {:?}", event);
    })?;

    let error = connect_wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        &mut esp_wifi,
        sysloop.clone(),
    );
    if let Some(error) = error.err() {
        // Red!
        led.set_pixel(RGB8::new(50, 0, 0))?;
        log::error!("Could not connect to Wi-Fi network: {:?}", error);
        unsafe { esp_restart() };
    };

    loop {
        // Blue!
        led.set_pixel(RGB8::new(0, 0, 50))?;
        let measurement = read_waveplus(&serial)?;

        println!("Received measurement {:?}", measurement);

        if !app_config.server.is_empty()
            && send_measurement(app_config.server, &measurement)
                .err()
                .is_some()
        {
            log::error!("wifi: {:?}", esp_wifi.is_connected());
            led.set_pixel(RGB8::new(50, 0, 0))?;
            let error = connect_wifi(
                app_config.wifi_ssid,
                app_config.wifi_psk,
                &mut esp_wifi,
                sysloop.clone(),
            );
            if let Some(error) = error.err() {
                log::error!("Could not connect to Wi-Fi network: {:?}", error);
                unsafe { esp_restart() };
            };
            if send_measurement(app_config.server, &measurement)
                .err()
                .is_some()
            {
                log::error!("Failed to send measurement after reconnect to wifi");
            }
        }
        // Green!
        led.set_pixel(RGB8::new(0, 50, 0))?;

        // Wait...
        std::thread::sleep(std::time::Duration::from_secs(
            app_config.read_interval.into(),
        ));
    }
}
